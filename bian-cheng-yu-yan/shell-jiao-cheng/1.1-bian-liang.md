# 1.1 变量

```shell
name="JTZ" # 定义一个变量
echo $name # 输出变量
```

> * 在 Bash 中为 `弱类型的变量`
> * `$` : 取出变量值

## 变量引用

```shell
#!/bin/bash

# 定义一个简单的变量，并输出

name=JTZ
echo $name # 输出 name 的值为 JTZ

#-----------------------------------------
# 注意：
# 在初始化变量时赋值号的两层不允许用空格值出现
#-----------------------------------------

# 输出字符串
echo name       # 输出 name
echo "name"     # 输出 name

# 1. 变量引用
echo $name      # 输出变量的值 JTZ
echo ${name}
# 2. 字符串内变量引用
echo "我的名字是： $name"       # 输出 我的名字是 JTZ
echo '$name'    # 这会输出 $name

#---------------------------------------
# 注意：
# 单引号会禁用掉（转义）变量的应用，这将会导致 $ 以普通字符串的形式输出
#---------------------------------------


# 空值 & NULL
name=           # 这表明将 name  的值设置为 name=""
unset name      # 这是删除变量的命令，其结果和上面 name="" 相同

exit #执行结束
exit $? # 也是执行结束只不过 $? 是最后一条命令退出状态，执行成功为 0 否则其他
```

## 变量赋值

```shell
#!/bin/bash

# 1. 常规的变量赋值
name="JTZ"

# 2. 读取命令行输入作为参数的值
echo "请求输入 name 的值： "
read name

# 3. 使用命令替换结构
a=`echo HELLO!` # 将 echo 结构交给 a 变量
echo $a

b=`echo HELLO`
echo $b

#------------------------------------------
# 注意：
# 在使用命令替换结构中包含 ! 在命令行中使用有效
# 因为不加 ! 会触发 Bash  的 history 机制
# 在 SHELL 脚本内， Bash 的历史机制默认关闭
#------------------------------------------

a=`ls -l`
# 不带引号引用会移除所有的空格字符
echo $a
echo "$a"

# 4. 使用 $(...) 形式赋值, 这是一个与反引号不同的新形式
b=$(ls -l)

# 5. 位置参数
#------------------------------------------
# 注意:
# $0 表示脚本名称， $1~$9 表示第 1~9 个参数 第十个参数之后需要使用 ${n} 表示
# $* 和 $@ 代表所有位置参数
# $# 表示传入参数的个数
#------------------------------------------

echo "脚本名称为： $0"
echo "第一个参数为：$1"
echo "传入参数的个数： $#"

# 扩展
# 使用 shift 命令可以将全体位置参数向左移一位, 重新赋值。$1 <--- $2, $2 <--- $3, $3 <--- $4，以此类推
until [ -z "$1" ]  # 直到访问完所有的参数
do
  echo -n "$1 "
  shift 1  # 这里默认是 1
done

echo               # 换行。

# 那些被访问完的参数又会怎样呢？
echo "$2"
# 什么都不会被打印出来。
# 当 $2 被移动到 $1 且没有 $3 时，$2 将会保持空。
# 因此 shift 是移动参数而非复制参数。

exit #执行结束
exit $? # 也是执行结束只不过 $? 是最后一条命令退出状态，执行成功为 0 否则其他
```

## Bash 弱类型变量

> * 本质上说， Bash 变量是`字符串`
> * Bash 是否允许变量进行算术运算和比较，决定因素是变量值是否`只含有数字`

```shell
#!/bin/bash
# int-or-string.sh

a=2334                   # 整数。
let "a += 1"
echo "a = $a "           # a = 2335
echo                     # 依旧是整数。


b=${a/23/BB}             # 将 "23" 替换为 "BB"。
                         # $b 变成了字符串。
echo "b = $b"            # b = BB35
declare -i b             # 将其声明为整数并没有什么卵用。
echo "b = $b"            # b = BB35

let "b += 1"             # BB35 + 1
echo "b = $b"            # b = 1
echo                     # Bash 认为字符串的"整数值"为0。

c=BB34
echo "c = $c"            # c = BB34
d=${c/BB/23}             # 将 "BB" 替换为 "23"。
                         # $d 变为了一个整数。
echo "d = $d"            # d = 2334
let "d += 1"             # 2334 + 1
echo "d = $d"            # d = 2335
echo


# 如果是空值会怎样呢？
e=''                     # ...也可以是 e="" 或 e=
echo "e = $e"            # e =
let "e += 1"             # 空值是否允许进行算术运算？
echo "e = $e"            # e = 1
echo                     # 空值变为了一个整数。

# 如果时未声明的变量呢？
echo "f = $f"            # f =
let "f += 1"             # 是否允许进行算术运算？
echo "f = $f"            # f = 1
echo                     # 未声明变量变为了一个整数。
#
# 然而……
let "f /= $undecl_var"   # 可以除以0么？
#   let: f /= : syntax error: operand expected (error token is " ")
# 语法错误！在这里 $undecl_var 并没有被设置为0！
#
# 但是，仍旧……
let "f /= 0"
#   let: f /= 0: division by 0 (error token is "0")
# 预期之中。


# 在执行算术运算时，Bash 通常将其空值的整数值设为0。
# 但是不要做这种事情！
# 因为这可能会导致一些意外的后果。


# 结论：上面的结果都表明 Bash 中的变量是弱类型的。

exit #执行结束
exit $? # 也是执行结束只不过 $? 是最后一条命令退出状态，执行成功为 0 否则其他
```
